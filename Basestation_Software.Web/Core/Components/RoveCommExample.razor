@implements IDisposable
@inject RoveCommService _RoveCommService

<div class="card full-height">
    <div class="card-header">
        <h5>RoveComm Test</h5>
    </div>

    <p>Accelerometer Data: @driveAccelDataX</p>

</div>


@code
{
    float driveAccelDataX = 0;

    protected override async Task OnInitializedAsync()
    {
        // Set a block of code to run when basestation recieves a telemetry packet from rovecomm
        // The format of parameters is: Board name, Packet Type name, and callback function
        _RoveCommService.On<float>("Core", "AccelerometerData", async (packet) =>
        {
            // Information about boards, packet type names, and telemetry packet's return values can be found in the rovecomm manifest.
            // This telemetry packet returns a list of floats for Accelerometer data in the form [x, y, z].

            // Sets variable to X value of accelerometer data.
            driveAccelDataX = packet.Data[0];

            // The data type this packet returns, in this case a float.
            Console.WriteLine(packet.DataType);

            // Amount of this data type this packet returns, in this case 3. [x, y, z]
            Console.WriteLine(packet.DataCount);

            // We probably want to re-render after recieving new data.
            await InvokeAsync(StateHasChanged);
        });

        // More consise version of the above without comments
        _RoveCommService.On<float>("Core", "AccelerometerData", async (packet) =>
        {
            driveAccelDataX = packet.Data[0];
            await InvokeAsync(StateHasChanged);
        });

        // Using a pre-existing function instead of an anonymous one as the callback
        _RoveCommService.On<float>("Core", "AccelerometerData", OnRecievedAccelerometerData);

        // Send a packet to a board.
        // The format of parameters is: Board name, Packet Type name, and value to send
        // Setting "reliable" will cause the packet to be sent over TCP rather than UDP
        _ = _RoveCommService.SendAsync<float>("Core", "DriveLeftright", [60.5f, -50.0f], reliable: false);

        // Subscribe to all telemetry packets that return the int type.
        _RoveCommService.On<int>(0, OnRecievedAny);

        // Subscribe to all DataIDs for all other possible packet types.
        _RoveCommService.On<sbyte>(0, OnRecievedAny);
        _RoveCommService.On<byte>(0, OnRecievedAny);
        _RoveCommService.On<short>(0, OnRecievedAny);
        _RoveCommService.On<ushort>(0, OnRecievedAny);
        _RoveCommService.On<uint>(0, OnRecievedAny);
        _RoveCommService.On<float>(0, OnRecievedAny);
        _RoveCommService.On<double>(0, OnRecievedAny);
        _RoveCommService.On<char>(0, OnRecievedAny);


        await InvokeAsync(StateHasChanged);
    }

    public async Task OnRecievedAccelerometerData(RoveCommPacket<float> packet)
    {
        driveAccelDataX = packet.Data[0];
        await InvokeAsync(StateHasChanged);
    }

    public async Task OnRecievedAny<T>(RoveCommPacket<T> packet)
    {
        // RoveCommUtils allows you to find a packet name by it's DataID
        if (RoveCommUtils.FindNameByDataID(packet.DataID, out string? boardName, out string? packetName))
        {
            Console.WriteLine($"Received {packetName} from {boardName}. Data: {packet.Data}");
        }
        else
        {
            Console.WriteLine($"Received Packet with unknown DataID {packet.DataID}. Data: {packet.Data}");
        }

        await InvokeAsync(StateHasChanged);
    }

    void IDisposable.Dispose()
    {
        
    }
}
